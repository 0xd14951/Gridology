<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Gridology</title>
  <style>
    :root{
      --bg: #ffffff;
      --card: #ffffff;
      --cardSolid: #ffffff;
      --text: #111111;
      --muted: #6b7280;
      --border: #e5e7eb;
      --panel: #ffffff;
      --shadow: 0 6px 20px rgba(0,0,0,.08);
      --shadow2: 0 4px 14px rgba(0,0,0,.06);
      --radius: 20px;
      --radius2: 16px;
      --touch: 44px;

      --primary: #111111;
      --accent: #111111;
      --danger: #ff3b30;
      --amber: #ff9f0a;
    }
    *{ box-sizing:border-box; }
    html, body{
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #ffffff;
      color: var(--text);
      padding: env(safe-area-inset-top) 14px calc(env(safe-area-inset-bottom) + 14px);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    body{
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
      color: var(--text);
      padding: env(safe-area-inset-top) 14px calc(env(safe-area-inset-bottom) + 14px);
    }
    .appWrap{ max-width:1100px; margin:0 auto; }
    .card{ background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden; }
    .topbar{
      padding: 16px 16px 10px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .title{ font-size:20px; font-weight:900; margin:0; letter-spacing:-.2px; }
    .subtitle{ margin:6px 0 0; font-size:13px; color:var(--muted); line-height:1.35; max-width: 760px; }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; overflow-x:auto; -webkit-overflow-scrolling:touch; }
    .btn{
      color: #111111;
      appearance:none;
      border:none;
      border-radius:12px;
      padding:10px 12px;
      min-height:40px;
      font-weight:900;
      font-size:13px;
      color:#fff;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,.14);
      touch-action: none;
      transform: translateZ(0);
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{
      background: #111111;
      border-color: #111111;
      color: #ffffff;
    }
    .btn.ghost{ background:#fff; color:var(--text); border:2px solid var(--border); box-shadow:none; }
    .btn.amber{ background: var(--btn4); }

    .content{
      display:grid;
      grid-template-columns: 1fr;
      gap: 0;
      padding: 14px;
    }
    .stage{
      background:#ffffff;
      border-radius:var(--radius2);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      align-items:flex-start;
      justify-content:center;
      min-height:380px;
      position:relative;
      width:100%;
    }
    .stageHint{
      position:absolute;
      left: 10px;
      top: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.9);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      display:none;
      gap:8px;
      align-items:center;
      z-index: 2;
      user-select:none;
    }
    .pillDot{ width:8px; height:8px; border-radius:99px; background:#ef4444; display:inline-block; }

    .panel{
      background: #ffffff;
      border-radius: var(--radius2);
      border: 1px solid var(--border);
      padding: 12px;
      position: sticky;
      top: 12px;
      height: fit-content;
    }
    .panel.hiddenDesktop{ display:none; }

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .panelTitle{ margin:0; font-size:14px; font-weight:900; color:#374151; }
    .toggleRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px;
      background:#fff;
      border:1px solid var(--border);
      border-radius:12px;
      margin-bottom:10px;
      cursor:pointer;
      user-select:none;
      min-height: var(--touch);
    }
    .toggleRow .lbl{ font-size:13px; font-weight:900; color:#374151; }
    .switch{ width:44px; height:26px; border-radius:999px; background:#e5e7eb; position:relative; flex:none; }
    .switch.on{ background:#111827; }
    .switchDot{ width:22px; height:22px; background:#fff; border-radius:999px; position:absolute; top:2px; left:2px; transition:transform .15s ease; box-shadow:0 4px 10px rgba(0,0,0,.15); }
    .switch.on .switchDot{ transform: translateX(18px); }

    .sliderBlock{
      background:#fff;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      margin-bottom:10px;
    }
    .sliderLabel{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:baseline;
      margin-bottom:8px;
      color:#374151;
      font-size:13px;
      font-weight:900;
    }
    .sliderValue{ color:var(--muted); font-weight:800; font-size:12px; white-space:nowrap; }
    input[type="range"]{ width:100%; height:28px; cursor:pointer; min-height: var(--touch); }

    .help{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .drop{
      margin: 14px;
      border: 2px dashed #94a3b8;
      border-radius: var(--radius2);
      padding: 42px 16px;
      text-align:center;
      background: #f8fafc;
      cursor:pointer;
      user-select:none;
    }
    .drop .big{ font-size:16px; font-weight:900; margin: 10px 0 6px; color:#334155; }
    .drop .small{ font-size:13px; color: var(--muted); }
    .kbdTag{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 6px;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      color: #111827;
      white-space: nowrap;
    }

    @media (max-width: 860px){
      body{ padding: env(safe-area-inset-top) 10px calc(env(safe-area-inset-bottom) + 10px); }
      .topbar{ padding: 14px 14px 10px; }
      .title{ font-size:18px; }
      .subtitle{ font-size:12.5px; }
      .content{ grid-template-columns: 1fr; padding: 12px; }
      .stage{ min-height: calc(100vh - 130px); }
      .stageHint{ display:none; }
      .panel{
        position: fixed;
        left: 10px;
        right: 10px;
        bottom: calc(env(safe-area-inset-bottom) + 10px);
        top: auto;
        z-index: 30;
        max-height: 52vh;
        overflow: auto;
        box-shadow: var(--shadow);
        display:none;
      }
      .panel.open{ display:block; }
      .panelHeader .btn{ min-height: 40px; }
}
  

    /* UX: hide manual controls UI completely */
    .panel{ display:none !important; }


    /* UX: Mandarin (Taiwan) only ‚Äì hide language toggle */
    


    /* Hide subtitle area completely */
    #subtitle{ display:none !important; }


    /* Mobile: let the canvas fill the available viewport (no fixed 70vh) */
    .stage{ width:100%; height:100%; }
    #content{ height: calc(100vh - 56px); }
    @media (max-width: 720px){
      .card{ border:none; border-radius:0; box-shadow:none; }
      .topbar{ position:sticky; top:0; z-index:10; background:#fff; }
      #content{ height: calc(100vh - 56px); }
      .stage{ height: calc(100vh - 56px); }
            canvas#canvas{ background:#ffffff; }
canvas#canvas{ max-width:none !important; max-height:none !important; }
    }


    /* iPhone full-screen canvas */

    @media (max-width: 860px){
      html, body{ height:100%; }
      body{ padding: 0 !important; margin:0; }
      .appWrap{ max-width:none; margin:0; }
      .card{ border:none; border-radius:0; box-shadow:none; height:100dvh; }
      .topbar{
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 50;
        background: rgba(255,255,255,.92);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding-top: calc(env(safe-area-inset-top) + 10px);
      }
      #content{ padding:0 !important; margin:0; height: 100dvh;  padding-top: var(--topbarH, 0px);}
      .stage{
        width:100%;
        height: calc(100dvh - var(--topbarH, 0px) - env(safe-area-inset-bottom));
        min-height: 0;
        border-radius: 0;
        overflow: hidden;
      }
      canvas#canvas{ max-width:none !important; max-height:none !important; }
      /* Hide the upload drop area once an image is loaded (JS toggles display anyway) */
      #drop{ margin:0; border-radius:0; }
    }

</style>
</head>
<body>
  <div class="appWrap">
    <div class="card">
      <div class="topbar">
        <div>
          <h1 class="title" id="title"></h1>
</div>
        <div class="actions" id="actions">
</div>
      </div>

      <div id="drop" class="drop">
        <div style="font-size:34px">üñºÔ∏è</div>
        <div class="big" id="dropTitle"></div>
<input id="file" type="file" accept="image/*" style="display:none" />
      </div>

      <div id="content" class="content" style="display:none">
        <div class="stage">
<canvas id="canvas" style="display:block; touch-action:none;"></canvas>
        </div>

        <div id="panel" class="panel">
          <div class="panelHeader">
            <div class="panelTitle" id="controlsTitle"></div>
            <button class="btn ghost" id="closePanelBtn" style="display:none"></button>
          </div>

          <div id="toggleGridRow" class="toggleRow" role="button">
            <div class="lbl" id="showGridLbl"></div>
            <div class="switch" id="gridSwitch"><div class="switchDot"></div></div>
          </div>

          <div class="sliderBlock">
            <div class="sliderLabel"><span id="rotLbl"></span><span class="sliderValue" id="rotVal"></span></div>
            <input id="rot" type="range" min="-180" max="180" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="zoomLbl"></span><span class="sliderValue" id="zoomVal"></span></div>
            <input id="zoom" type="range" min="0.1" max="5" step="0.05" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="gwLbl"></span><span class="sliderValue" id="gwVal"></span></div>
            <input id="gw" type="range" min="40" max="6000" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="ghLbl"></span><span class="sliderValue" id="ghVal"></span></div>
            <input id="gh" type="range" min="40" max="6000" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="pxLbl"></span><span class="sliderValue" id="pxVal"></span></div>
            <input id="px" type="range" min="-4000" max="4000" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="pyLbl"></span><span class="sliderValue" id="pyVal"></span></div>
            <input id="py" type="range" min="-4000" max="4000" step="1" />
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:6px">
            <button class="btn amber" id="resetBtn"></button>
            <button class="btn ghost" id="newBtn"></button>
          </div>
</div>
        </div>
      </div>
    </div>
  </div>

  <script>

    // ---------- i18n ----------
    const I18N = {
      en: {
        title: "Gridology",
        subtitle: `Drag to move. Drag the corner dots to rotate + resize. Drag edge dots to resize. Scroll to zoom. Hold <span class="kbdTag">Shift</span> to rotate only. <span class="kbdTag">Ctrl/‚åò+S</span> to download.`,
        dropTitle: "‰∏äÂÇ≥ÂúñÁâá",
stageHint: "Drag canvas ‚Ä¢ Controls (optional)",
        download: "Download",
        controls: "Controls",
        showControls: "Controls",
        hideControls: "Hide Controls",
        close: "Close",
        showGrid: "Show grid",
        rotation: "Rotation",
        zoom: "Zoom",
        gridWidth: "Grid width",
        gridHeight: "Grid height",
        posX: "Position X",
        posY: "Position Y",
        reset: "Reset",
        newImage: "New image",
        tipsTitle: "Mobile tips",
        tips: [
          "Pinch to zoom. Use two fingers to rotate + move the grid.",
          "Corner dots rotate + resize. Edge dots resize only.",
          "Hold Shift for rotation-only."
        ],
        langToggle: "‰∏≠Êñá",
        langLabel: "Language",
      },
      "zh-TW": {
        title: "Gridology",
        subtitle: ``,
        dropTitle: "‰∏äÂÇ≥ÂúñÁâá",
stageHint: "ÊãñÊõ≥Áï´Èù¢ ‚Ä¢ ÊéßÂà∂È†ÖÔºàÂèØÈÅ∏Ôºâ",
        download: "‰∏ãËºâ",
        lockImage: "ÈéñÂÆöÂúñÁâá",
        unlockImage: "Ëß£ÈéñÂúñÁâá",
        a3Portrait: "A3 Áõ¥Âºè",
        a3Landscape: "A3 Ê©´Âºè",
        controls: "ÊéßÂà∂È†Ö",
        showControls: "ÊéßÂà∂È†Ö",
        hideControls: "Èö±ËóèÊéßÂà∂È†Ö",
        close: "ÈóúÈñâ",
        showGrid: "È°ØÁ§∫‰πùÂÆÆÊ†º",
        rotation: "ÊóãËΩâËßíÂ∫¶",
        zoom: "Á∏ÆÊîæ",
        gridWidth: "‰πùÂÆÆÊ†ºÂØ¨Â∫¶",
        gridHeight: "‰πùÂÆÆÊ†ºÈ´òÂ∫¶",
        posX: "Ê∞¥Âπ≥‰ΩçÁΩÆ",
        posY: "ÂûÇÁõ¥‰ΩçÁΩÆ",
        reset: "ÈáçË®≠",
        newImage: "‰∏äÂÇ≥Êñ∞ÂúñÁâá",
        tipsTitle: "ÊâãÊ©üÊìç‰ΩúÊèêÁ§∫",
        tips: [
          "ÈõôÊåáÂèØÁ∏ÆÊîæÔºõÈõôÊåáÊóãËΩâÂèØËΩâÂãïÁ∂≤Ê†ºÔºõÈõôÊåáÁßªÂãïÂèØÂπ≥ÁßªÁ∂≤Ê†º„ÄÇ",
          "ËßíÈªûÔºöÊóãËΩâÔºãË™øÊï¥Â§ßÂ∞èÔºõÈÇäÈªûÔºöÂè™Ë™øÊï¥Â§ßÂ∞è„ÄÇ",
          "Êåâ‰Ωè Shift ÂèØÂè™ÊóãËΩâ„ÄÇ"
        ],
        langToggle: "EN",
        langLabel: "Ë™ûË®Ä",
      },
    };

    function detectLang(){
      const saved = localStorage.getItem("grid_lang");
      if (saved && I18N[saved]) return saved;
      const nav = (navigator.language || "").toLowerCase();
      if (nav.startsWith("zh")) return "zh-TW";
      return "en";
    }

    let lang = "zh-TW";
let lastExportName = localStorage.getItem("gridology_filename") || "gridology";
    function t(k){ return (I18N[lang] && I18N[lang][k]) || I18N.en[k] || k; }
    function applyLang(){
      document.documentElement.lang = lang;
      localStorage.setItem("grid_lang", lang);
      document.getElementById("title").textContent = t("title");
            const subEl = document.getElementById("subtitle");
      if (subEl) subEl.innerHTML = t("subtitle");
document.getElementById("dropTitle").textContent = t("dropTitle");
const hintEl = document.getElementById("stageHint");
      if (hintEl) hintEl.textContent = t("stageHint");
document.getElementById("controlsTitle").textContent = t("controls");
      document.getElementById("showGridLbl").textContent = t("showGrid");
      document.getElementById("rotLbl").textContent = t("rotation");
      document.getElementById("zoomLbl").textContent = t("zoom");
      document.getElementById("gwLbl").textContent = t("gridWidth");
      document.getElementById("ghLbl").textContent = t("gridHeight");
      document.getElementById("pxLbl").textContent = t("posX");
      document.getElementById("pyLbl").textContent = t("posY");
      document.getElementById("resetBtn").textContent = t("reset");
      document.getElementById("newBtn").textContent = t("newImage");
      document.getElementById("tipsTitle").textContent = t("tipsTitle");
      const tips = t("tips");
      document.getElementById("tips").innerHTML = (Array.isArray(tips) ? tips : String(tips).split("\n"))
        .map(line => `<div>‚Ä¢ ${line}</div>`).join("");
            // language toggle removed (zh-TW only)
      // control button label updated in updateControlsButton()
      updateControlsButton();
    }

    // ---------- State ----------
    const GRID_COLOR = "#ff0000";
    const GRID_OPACITY = 1.0;
    const LINE_WIDTH_PX = 16; // increased for mobile visibility

    let img = null;
    let imgLoaded = false;

    
    // North alignment tool state
    let northMode = false;
    let northP1 = null;
    let northP2 = null;

    let northAligned = false; // becomes true after alignment
    let northDrawing = false;
let showGrid = true;
    let rotation = 0;   // degrees (grid)
    let zoom = 1.0;        // (grid)
    let offset = { x: 0, y: 0 }; // image pixels (grid pivot offset)

    // Image transform (Option A: tap to select image vs grid)
    let imgRotation = 0;   // degrees
    let imgZoom = 1.0;
    let imgOffset = { x: 0, y: 0 }; // image pixels (image pivot offset)

    // Which layer is currently selected for editing: "grid" | "image"
    let selectedLayer = "grid";

    let gridSize = { w: 600, h: 600 }; // image pixels

    let exportMode = false;

    let isShift = false;
    let isDragging = false;
    let activeHandle = null; // tl,tr,bl,br,t,r,b,l or null
    let activeLayer = "grid"; // "grid" | "image"
    let imageLocked = false; // when true, image won\'t interfere with grid
    let paperOrientation = "landscape"; // landscape-only
    const A3_MM = { w: 297, h: 420 };
    const PX_PER_MM_MOBILE = 8;   // internal canvas resolution
    const PX_PER_MM_DESKTOP = 7;
    function getA3PxDims(){
      const ppm = isMobile() ? PX_PER_MM_MOBILE : PX_PER_MM_DESKTOP;
      const w = Math.round(A3_MM.w * ppm);
      const h = Math.round(A3_MM.h * ppm);
      return (paperOrientation === "portrait") ? { w, h } : { w: h, h: w };
    }
    let lastPointer = { x: 0, y: 0 };

    // Canvas + sizing
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
const meta = { naturalWidth: 0, naturalHeight: 0,
      canvasWidth: 0,
      canvasHeight: 0, displayWidth: 0, displayHeight: 0 };
    
    

    // Workspace size (iPhone-friendly 4:3)
    const WORKSPACE_W = 3024;
    const WORKSPACE_H = 4032;
// Initialize workspace even before an image is loaded
    (function initWorkspace(){
      meta.canvasWidth = meta.canvasWidth || WORKSPACE_W;
      meta.canvasHeight = meta.canvasHeight || WORKSPACE_H;
      canvas.width = meta.canvasWidth;
      canvas.height = meta.canvasHeight;
    })();
// Controls panel: hidden by default
    let controlsOpen = false;

    function isMobile(){ return window.matchMedia && window.matchMedia("(max-width: 860px)").matches; }

    function clamp(v, mn, mx){ return Math.max(mn, Math.min(mx, v)); }
    function degToRad(d){ return (d * Math.PI) / 180; }
    function normDeg(d){
      let x = d;
      while (x > 180) x -= 360;
      while (x < -180) x += 360;
      return x;
    }

    function alignNorthToBottom(){
      if (!northP1 || !northP2) return;

      const dx = northP2.x - northP1.x;
      const dy = northP2.y - northP1.y;

      // North direction angle in canvas coords (y grows downward)
      const angleNorth = Math.atan2(dy, dx) * 180 / Math.PI;

      // Bottom direction is +Y (down) => +90 degrees
      const desired = 90;

      const delta = desired - angleNorth;

      imgRotation = normDeg(imgRotation + delta);

      northAligned = true;
      northMode = false;
      draw();
    }

    // Rotate the GRID so that the user-drawn North arrow points to the bottom edge (down).
    function alignGridNorthToBottom(p1 = northP1, p2 = northP2){
      if (!p1 || !p2) return;

      // Arrow direction in canvas coords (y grows downward)
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const angle = Math.atan2(dy, dx) * 180 / Math.PI; // [-180,180]

      // We want ONE grid edge axis (horizontal OR vertical) to align with the arrow path.
      // If rotation=0, grid edges are axis-aligned:
      //   - grid horizontal edges angle = rotation (+0)
      //   - grid vertical edges angle   = rotation (+90)
      // So candidates for rotation that align an edge with the arrow are:
      //   1) rotation = angle  (arrow aligns with horizontal edges)
      //   2) rotation = angle - 90 (arrow aligns with vertical edges)
      const cand1 = normDeg(angle);
      const cand2 = normDeg(angle - 90);

      // choose the candidate that requires the smallest change from current rotation
      function angDist(a, b){
        let d = normDeg(a - b);
        if (d > 180) d = 360 - d;
        return Math.abs(d);
      }
      const d1 = angDist(cand1, rotation);
      const d2 = angDist(cand2, rotation);

      rotation = (d1 <= d2) ? cand1 : cand2;

      // Reduce floating drift so the grid edge visually matches the arrow perfectly
      rotation = Math.round(rotation * 1000) / 1000;

      northAligned = true; // reuse flag as "aligned"
      draw();
    }



    // ---------- UI wiring ----------
    const drop = document.getElementById("drop");
    const fileInput = document.getElementById("file");
    const content = document.getElementById("content");
    const panel = document.getElementById("panel");
    const closePanelBtn = document.getElementById("closePanelBtn");
    const actions = document.getElementById("actions");
// Add action buttons (download + controls) once image is loaded
    const downloadBtn = document.createElement("button");
    downloadBtn.className = "btn primary";
    downloadBtn.addEventListener("click", () => downloadImage());
    actions.appendChild(downloadBtn);
    downloadBtn.style.display = "none";


    

    // New image button (lets user upload another plan)
    const newImageBtn = document.createElement("button");
    newImageBtn.className = "btn ghost";
    newImageBtn.textContent = "‰∏äÂÇ≥Êñ∞ÂúñÁâá";
    newImageBtn.addEventListener("click", () => {
      // Open picker; if user cancels, keep current image
      fileInput.value = "";
      fileInput.click();
    });
    actions.appendChild(newImageBtn);
    newImageBtn.style.display = "none";
const lockBtn = document.createElement("button");
    lockBtn.className = "btn ghost";
    lockBtn.addEventListener("click", () => {
      imageLocked = !imageLocked;
      try { localStorage.setItem("gridology_image_locked", imageLocked ? "1" : "0"); } catch(e){}
      if (imageLocked){
        selectedLayer = "grid";
        activeLayer = "grid";
        activeHandle = null;
        gesture.active = false;
      }
      updateControlsButton();
      draw();
    });
    actions.appendChild(lockBtn);
    lockBtn.style.display = "none";
    

    // --- North alignment buttons ---
    const northBtn = document.createElement("button");
    northBtn.className = "btn ghost";
    northBtn.addEventListener("click", () => {
      // Only allow North alignment when the GRID layer is selected.
      // (You select the grid by tapping on it / using the grid handles.)
      if (activeLayer !== "grid") {
        // brief hint
        const prev = northBtn.textContent;
        northMode = false;
        northDrawing = false;
        northP1 = northP2 = null;
        northBtn.textContent = northMode ? "ÁªòÂà∂ÂåóÂêëÁÆ≠Â§¥" : "ÂåóÊñπ‰ΩçÁΩÆ";
        setTimeout(() => { northBtn.textContent = northMode ? "ÁªòÂà∂ÂåóÂêëÁÆ≠Â§¥" : "ÂåóÊñπ‰ΩçÁΩÆ"; }, 900);
        draw();
        return;
      }

      // Enter North draw mode: drag an arrow (base -> tip). On release, grid auto-rotates so North points down.
      northMode = !northMode;
      northDrawing = false;
      northAligned = false;
      northP1 = northP2 = null;
      draw();
    });
    actions.appendChild(northBtn);
// A3 portrait/landscape toggle removed (landscape-only)
    // Restore image lock state
    try { imageLocked = localStorage.getItem("gridology_image_locked") === "1"; } catch(e) { imageLocked = false; }
    /* portrait/landscape option removed: always landscape */
    paperOrientation = "landscape";
const controlsBtn = document.createElement("button");
    controlsBtn.className = "btn ghost";
    controlsBtn.addEventListener("click", () => toggleControls());
    actions.appendChild(controlsBtn);
    controlsBtn.style.display = "none";

    

    // Help button (always visible)
    const helpBtn = document.createElement("button");
    helpBtn.className = "btn ghost";
    helpBtn.textContent = "‰ΩøÁî®Ë™™Êòé";
    helpBtn.addEventListener("click", () => {
      const m = document.getElementById("helpModal");
      if (m) m.style.display = "block";
    });
    actions.appendChild(helpBtn);
function updateControlsButton(){
      const hasImage = !!imgLoaded;
      if (!hasImage) { northMode = false; northDrawing = false; }
      downloadBtn.style.display = hasImage ? "inline-block" : "none";
      
      newImageBtn.style.display = hasImage ? "inline-block" : "none";
lockBtn.style.display = hasImage ? "inline-block" : "none";
      
      northBtn.style.display = hasImage ? "inline-block" : "none";
controlsBtn.style.display = "none";
      controlsBtn.textContent = controlsOpen ? t("hideControls") : t("showControls");
      downloadBtn.textContent = t("download");
      lockBtn.textContent = imageLocked ? t("unlockImage") : t("lockImage");
      
      northBtn.textContent = northMode ? "ÁªòÂà∂ÂåóÂêëÁÆ≠Â§¥" : "ÂåóÊñπ‰ΩçÁΩÆ";
closePanelBtn.textContent = t("close");
      // show close button only on mobile when panel open
      closePanelBtn.style.display = "none";
    }

    function setControlsOpen(open){ controlsOpen = false; panel.classList.remove("open"); panel.style.display = "none"; updateControlsButton(); }

    function toggleControls(){ setControlsOpen(!controlsOpen); }

    closePanelBtn.addEventListener("click", () => setControlsOpen(false));

    // Hidden by default
    setControlsOpen(false);

    // Drag & drop + click upload
    drop.addEventListener("click", () => fileInput.click());
    drop.addEventListener("dragover", (e) => e.preventDefault());
    drop.addEventListener("drop", (e) => {
      e.preventDefault();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) loadImageFile(f);
    });
    fileInput.addEventListener("change", (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) loadImageFile(f);
      fileInput.value = "";
    });
    // controls elements
    const gridSwitch = document.getElementById("gridSwitch");
    document.getElementById("toggleGridRow").addEventListener("click", () => {
      showGrid = !showGrid;
      gridSwitch.classList.toggle("on", showGrid);
      draw();
    });

    const rotEl = document.getElementById("rot");
    const zoomEl = document.getElementById("zoom");
    const gwEl = document.getElementById("gw");
    const ghEl = document.getElementById("gh");
    const pxEl = document.getElementById("px");
    const pyEl = document.getElementById("py");
    const rotVal = document.getElementById("rotVal");
    const zoomVal = document.getElementById("zoomVal");
    const gwVal = document.getElementById("gwVal");
    const ghVal = document.getElementById("ghVal");
    const pxVal = document.getElementById("pxVal");
    const pyVal = document.getElementById("pyVal");

    function syncControls(){
      rotEl.value = rotation;
      zoomEl.value = zoom;
      gwEl.value = gridSize.w;
      ghEl.value = gridSize.h;
      pxEl.value = offset.x;
      pyEl.value = offset.y;

      rotVal.textContent = `${rotation}¬∞`;
      zoomVal.textContent = `${zoom.toFixed(2)}x`;
      gwVal.textContent = `${gridSize.w}px`;
      ghVal.textContent = `${gridSize.h}px`;
      pxVal.textContent = `${Math.round(offset.x)}px`;
      pyVal.textContent = `${Math.round(offset.y)}px`;

      gridSwitch.classList.toggle("on", showGrid);
      updateControlsButton();
    }

    function onSlider(el, fn){
      el.addEventListener("input", () => { fn(parseFloat(el.value)); syncControls(); draw(); });
    }
    onSlider(rotEl, (v) => rotation = normDeg(v));
    onSlider(zoomEl, (v) => zoom = clamp(v, 0.1, 5));
    onSlider(gwEl, (v) => gridSize.w = Math.round(v));
    onSlider(ghEl, (v) => gridSize.h = Math.round(v));
    onSlider(pxEl, (v) => offset.x = v);
    onSlider(pyEl, (v) => offset.y = v);

    document.getElementById("resetBtn").addEventListener("click", () => {
      rotation = 0;
          // Keep grid and image initially aligned, but leave workspace padding for "free" editing.
          const initialLayerZoom = isMobile() ? 1.15 : 1.0;
          zoom = initialLayerZoom;
          offset = { x: 0, y: 0 };

          imgRotation = 0;
          imgZoom = initialLayerZoom;
          imgOffset = { x: 0, y: 0 };
      syncControls(); draw();
    });

    document.getElementById("newBtn").addEventListener("click", () => {
      img = null; imgLoaded = false;
      drop.style.display = "block";
      content.style.display = "none";
      setControlsOpen(false);
          updateControlsButton();
    });

    // keyboard
    window.addEventListener("keydown", (e) => {
      if (e.key === "Shift") isShift = true;
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        downloadImage();
      }
      if (e.key.toLowerCase() === "g") {
        showGrid = !showGrid;
        syncControls(); draw();
      }
      if (e.key.toLowerCase() === "r") {
        rotation = 0; zoom = 1.0; offset = { x: 0, y: 0 };
        syncControls(); draw();
      }
      if (e.key === "Escape") {
        isDragging = false;
        activeHandle = null;
      }
    });
    window.addEventListener("keyup", (e) => { if (e.key === "Shift") isShift = false; });

    // ---------- Image loading ----------
    function loadImageFile(file){
      if (!file || !file.type || !file.type.startsWith("image/")) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const src = ev.target.result;
        const im = new Image();
        im.onload = () => {
          img = im;
          imgLoaded = true;
          meta.naturalWidth = im.naturalWidth || im.width;
          meta.naturalHeight = im.naturalHeight || im.height;


          // Workspace: give padding around the image so users can pan/rotate/scale without immediate clipping
          const WORKSPACE_FACTOR = 2.0; // double-size workspace (finite)
          const a3 = getA3PxDims();
          meta.canvasWidth = 4752;
  meta.canvasHeight = 4752;
// initial grid size: 90% of shorter side
          const short = Math.min(meta.naturalWidth, meta.naturalHeight);
          const side = Math.round(short * 0.9);
          gridSize = { w: side, h: side };
          rotation = 0; zoom = 1.0; offset = { x: 0, y: 0 };
          showGrid = true;

          // show canvas view
          drop.style.display = "none";
          content.style.display = "grid";
          setControlsOpen(false); // hidden by default as requested
          syncControls();
          layoutCanvas();
          draw();
        };
        im.src = src;
      };
      reader.readAsDataURL(file);
    }

    function layoutCanvas(){
      // keep internal canvas at fixed workspace size for export quality
      canvas.width = meta.canvasWidth || WORKSPACE_W;
      canvas.height = meta.canvasHeight || WORKSPACE_H;

      // display size responsive
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const mobile = isMobile();

      const topbarEl = document.querySelector(".topbar");
      const topbarH = (topbarEl) ? Math.round(topbarEl.getBoundingClientRect().height) : 0;

      // Expose measured topbar height to CSS so the stage can be sized correctly on iPhone
      document.documentElement.style.setProperty('--topbarH', topbarH + 'px');

      // Available viewport for the stage
      const availW = vw;
      const availH = Math.max(200, vh - (mobile ? topbarH : 0));

      const cw = (meta.canvasWidth || WORKSPACE_W);
      const ch = (meta.canvasHeight || WORKSPACE_H);

      let dw, dh;

      if (mobile){
        // iPhone/mobile: COVER the available screen so the canvas fills the display (no side gutters).
        // This may crop a little vertically/horizontally; user can pan inside the canvas.
        const scale = Math.max(availW / cw, availH / ch);
        dw = Math.ceil(cw * scale);
        dh = Math.ceil(ch * scale);
      } else {
        // Desktop: CONTAIN within the card area (no scrollbars), centered by flex stage.
        const maxW = Math.min(vw - 24, 1100);
        const maxH = Math.min(vh - 80, 760);
        const scale = Math.min(maxW / cw, maxH / ch, 1);
        dw = Math.floor(cw * scale);
        dh = Math.floor(ch * scale);
      }

      meta.displayWidth = dw;
      meta.displayHeight = dh;

      canvas.style.width = dw + "px";
      canvas.style.height = dh + "px";
    }

    window.addEventListener("resize", () => {
      layoutCanvas();
      updateControlsButton();
    });

    // ---------- Geometry helpers ----------
    function getPivot(layer){
      const ox = (layer === "image") ? imgOffset.x : offset.x;
      const oy = (layer === "image") ? imgOffset.y : offset.y;
      return { x: (meta.canvasWidth || meta.naturalWidth) / 2 + ox, y: (meta.canvasHeight || meta.naturalHeight) / 2 + oy };
    }
    function localToCanvas(layer, lx, ly){
      const p = getPivot(layer);
      const rot = (layer === "image") ? imgRotation : rotation;
      const z = (layer === "image") ? imgZoom : zoom;

      const rad = degToRad(rot);
      const cos = Math.cos(rad), sin = Math.sin(rad);
      const x1 = lx * z, y1 = ly * z;
      const xr = x1 * cos - y1 * sin;
      const yr = x1 * sin + y1 * cos;
      return { x: p.x + xr, y: p.y + yr };
    }
    function canvasToLocalAtRot(layer, cx, cy, rotDeg){
      const p = getPivot(layer);
      const z = (layer === "image") ? imgZoom : zoom;

      const dx = cx - p.x;
      const dy = cy - p.y;
      const rad = degToRad(rotDeg);
      const cos = Math.cos(-rad), sin = Math.sin(-rad);
      const xr = dx * cos - dy * sin;
      const yr = dx * sin + dy * cos;
      return { x: xr / z, y: yr / z };
    }
    function getHandles(layer){
      const size = (layer === "image")
        ? { w: meta.naturalWidth, h: meta.naturalHeight }
        : gridSize;

      const hw = size.w / 2;
      const hh = size.h / 2;

      const hs = [
        { name:"tl", lx:-hw, ly:-hh },
        { name:"tr", lx: hw, ly:-hh },
        { name:"bl", lx:-hw, ly: hh },
        { name:"br", lx: hw, ly: hh },
        { name:"t",  lx:  0, ly:-hh },
        { name:"r",  lx: hw, ly:  0 },
        { name:"b",  lx:  0, ly: hh },
        { name:"l",  lx:-hw, ly:  0 },
      ];

      return hs.map(h => {
        const p = localToCanvas(layer, h.lx, h.ly);
        return { ...h, x:p.x, y:p.y };
      });
    }


    // --- Resize anchoring helpers (so only the dragged edge moves) ---
    const OPP_HANDLE = { tl:"br", tr:"bl", bl:"tr", br:"tl", t:"b", b:"t", l:"r", r:"l" };
    function localForHandleFromSize(handle, size){
      const hw = size.w / 2;
      const hh = size.h / 2;
      switch(handle){
        case "tl": return { x:-hw, y:-hh };
        case "tr": return { x: hw, y:-hh };
        case "bl": return { x:-hw, y: hh };
        case "br": return { x: hw, y: hh };
        case "t":  return { x:  0, y:-hh };
        case "r":  return { x: hw, y:  0 };
        case "b":  return { x:  0, y: hh };
        case "l":  return { x:-hw, y:  0 };
        default:   return { x:0, y:0 };
      }
    }
    function localToCanvasGridAt(lx, ly, rotDeg, pivot, z){
      const rad = degToRad(rotDeg);
      const cos = Math.cos(rad), sin = Math.sin(rad);
      const x1 = lx * z, y1 = ly * z;
      const xr = x1 * cos - y1 * sin;
      const yr = x1 * sin + y1 * cos;
      return { x: pivot.x + xr, y: pivot.y + yr };
    }

    
    // ---------- Workspace auto-expand (for image editing) ----------
    function getLayerBounds(layer){
      // Returns {minX,maxX,minY,maxY} in canvas coords
      const hs = getHandles(layer);
      if (!hs || !hs.corners) return null;
      const pts = hs.corners; // [p1,p2,p3,p4]
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const p of pts){
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
      return { minX, maxX, minY, maxY };
    }

    
    function maybeExpandWorkspace(layer){
      if (!imgLoaded) return;
      const bounds = getLayerBounds(layer);
      if (!bounds) return;

      const W = meta.canvasWidth || meta.naturalWidth;
      const H = meta.canvasHeight || meta.naturalHeight;

      // Padding target: keep some breathing room around the active layer
      const pad = Math.max(140, Math.min(W, H) * 0.12);

      const overflowLeft  = Math.max(0, pad - bounds.minX);
      const overflowRight = Math.max(0, bounds.maxX - (W - pad));
      const overflowTop   = Math.max(0, pad - bounds.minY);
      const overflowBot   = Math.max(0, bounds.maxY - (H - pad));

      const addW = 2 * Math.max(overflowLeft, overflowRight);
      const addH = 2 * Math.max(overflowTop, overflowBot);

      if (addW < 1 && addH < 1) return;

      const newW = Math.round(W + addW);
      const newH = Math.round(H + addH);

      const dx = (newW - W) / 2;
      const dy = (newH - H) / 2;

      // Shift BOTH layers so their world position stays put relative to viewport
      offset.x -= dx; offset.y -= dy;
      imgOffset.x -= dx; imgOffset.y -= dy;

      meta.canvasWidth = newW;
      meta.canvasHeight = newH;

      layoutCanvas();
      draw();
    }

    function maybeExpandWorkspaceForActiveLayer(){ /* auto-expand disabled (finite workspace) */ }
    
    // Ensure workspace is large enough so export won't crop rotated/scaled layers
    function ensureWorkspaceFitsAllLayers(){
      if (!imgLoaded) return false;

      const W = meta.canvasWidth || meta.naturalWidth;
      const H = meta.canvasHeight || meta.naturalHeight;

      const pad = Math.max(180, Math.min(W, H) * 0.14);

      const bImg = getLayerBounds("image");
      const bGrid = showGrid ? getLayerBounds("grid") : null;

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      const addBounds = (b) => {
        if (!b) return;
        minX = Math.min(minX, b.minX);
        maxX = Math.max(maxX, b.maxX);
        minY = Math.min(minY, b.minY);
        maxY = Math.max(maxY, b.maxY);
      };
      addBounds(bImg);
      addBounds(bGrid);

      if (!isFinite(minX) || !isFinite(minY)) return false;

      const overflowLeft  = Math.max(0, pad - minX);
      const overflowRight = Math.max(0, maxX - (W - pad));
      const overflowTop   = Math.max(0, pad - minY);
      const overflowBot   = Math.max(0, maxY - (H - pad));

      const addW = 2 * Math.max(overflowLeft, overflowRight);
      const addH = 2 * Math.max(overflowTop, overflowBot);

      if (addW < 1 && addH < 1) return false;

      const newW = Math.round(W + addW);
      const newH = Math.round(H + addH);

      const dx = (newW - W) / 2;
      const dy = (newH - H) / 2;

      // Shift BOTH layers so visual position stays stable
      offset.x -= dx; offset.y -= dy;
      imgOffset.x -= dx; imgOffset.y -= dy;

      meta.canvasWidth = newW;
      meta.canvasHeight = newH;

      layoutCanvas();
      return true;
    }

    function hitTestHandle(layer, cx, cy){
      const hs = getHandles(layer);
      const r = isMobile() ? 60 : 44; // larger hit area for handles (mobile-first)
      for (const h of hs){
        const dx = cx - h.x, dy = cy - h.y;
        if (Math.hypot(dx, dy) <= r) return h.name;
      }
      return null;
    }

    function pointInLayerRect(layer, cx, cy){
      const rot = (layer === "image") ? imgRotation : rotation;
      const local = canvasToLocalAtRot(layer, cx, cy, rot);
      const size = (layer === "image")
        ? { w: meta.naturalWidth, h: meta.naturalHeight }
        : gridSize;
      const pad = isMobile() ? 18 : 10;
      return Math.abs(local.x) <= size.w/2 + pad && Math.abs(local.y) <= size.h/2 + pad;
    }
    function clientToCanvas(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      return { x: (clientX - rect.left) * sx, y: (clientY - rect.top) * sy };
    }

    // ---------- Drawing ----------
    function draw(){
      if (!imgLoaded) return;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
// Draw image with its own transform
      ctx.save();
      const pImg = getPivot("image");
      ctx.translate(pImg.x, pImg.y);
      ctx.rotate(degToRad(imgRotation));
      ctx.scale(imgZoom, imgZoom);
      ctx.drawImage(img, -meta.naturalWidth/2, -meta.naturalHeight/2);
      ctx.restore();

      if (!showGrid) return;

      // Draw grid with its own transform
      const pivot = getPivot("grid");
      ctx.save();
      ctx.translate(pivot.x, pivot.y);
      ctx.rotate(degToRad(rotation));
      ctx.scale(zoom, zoom);

      const gw = gridSize.w, gh = gridSize.h;
      const x0 = -gw/2, y0 = -gh/2;

      ctx.strokeStyle = GRID_COLOR;
      ctx.globalAlpha = GRID_OPACITY;
      ctx.lineWidth = LINE_WIDTH_PX;

      const cellW = gw/3, cellH = gh/3;

      ctx.beginPath(); ctx.rect(x0, y0, gw, gh); ctx.stroke();

      for (let i=1;i<=2;i++){
        ctx.beginPath();
        ctx.moveTo(x0 + cellW*i, y0);
        ctx.lineTo(x0 + cellW*i, y0 + gh);
        ctx.stroke();
      }
      for (let i=1;i<=2;i++){
        ctx.beginPath();
        ctx.moveTo(x0, y0 + cellH*i);
        ctx.lineTo(x0 + gw, y0 + cellH*i);
        ctx.stroke();
      }

      // Handles (dots) ‚Äî show on selected layer only; hide during export
      if (!exportMode && selectedLayer === "grid"){
        const dotR = 24; // larger handles for touch
        ctx.globalAlpha = 1;
        ctx.fillStyle = GRID_COLOR;
        const pts = [
          { x:x0, y:y0 }, { x:x0+gw, y:y0 }, { x:x0, y:y0+gh }, { x:x0+gw, y:y0+gh },
          { x:x0+gw/2, y:y0 }, { x:x0+gw, y:y0+gh/2 }, { x:x0+gw/2, y:y0+gh }, { x:x0, y:y0+gh/2 },
        ];
        for (const pt of pts){
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, dotR, 0, Math.PI*2);
          ctx.fill();
        }
      }

      ctx.restore();

      // Image handles (drawn in canvas space using helper) ‚Äî only when selected
      if (!exportMode && selectedLayer === "image" && !imageLocked){
        const hs = getHandles("image");
        const dotR = 24; // larger handles for touch
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = GRID_COLOR;
        for (const h of hs){
          ctx.beginPath();
          ctx.arc(h.x, h.y, dotR, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Live North-arrow preview while drawing (base -> tip)
      if (!exportMode && (northMode || northDrawing) && northP1 && northP2) {
        // Use lastPointer as live tip if the drag hasn't updated yet
        const tip = (northDrawing && lastPointer) ? lastPointer : northP2;

        const dx = tip.x - northP1.x;
        const dy = tip.y - northP1.y;
        const dist = Math.hypot(dx, dy);

        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = isMobile() ? 10 : 8;
        ctx.strokeStyle = "rgba(220,0,0,0.95)";
        ctx.fillStyle = "rgba(220,0,0,0.95)";

        // shaft
        ctx.beginPath();
        ctx.moveTo(northP1.x, northP1.y);
        ctx.lineTo(tip.x, tip.y);
        ctx.stroke();

        // head (only if the arrow has a bit of length)
        if (dist > 10) {
          const ang = Math.atan2(dy, dx);
          const ah = isMobile() ? 26 : 20;
          const spread = Math.PI / 7;

          ctx.beginPath();
          ctx.moveTo(tip.x, tip.y);
          ctx.lineTo(
            tip.x - ah * Math.cos(ang - spread),
            tip.y - ah * Math.sin(ang - spread)
          );
          ctx.lineTo(
            tip.x - ah * Math.cos(ang + spread),
            tip.y - ah * Math.sin(ang + spread)
          );
          ctx.closePath();
          ctx.fill();
        }

        // base dot
        ctx.beginPath();
        ctx.arc(northP1.x, northP1.y, isMobile() ? 12 : 10, 0, Math.PI * 2);
        ctx.fill();

        // tip dot for precision
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, isMobile() ? 10 : 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

// Alignment overlay icon (screen-fixed, indicates North is aligned to bottom)
      if (!exportMode && northAligned) {
        const margin = isMobile() ? 26 : 22;
        const r = isMobile() ? 24 : 22;
        const cx = canvas.width - margin - r;
        const cy = canvas.height - margin - r;

        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.lineWidth = isMobile() ? 6 : 5;
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.fillStyle = "rgba(255,255,255,0.75)";

        // bubble
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // arrow pointing DOWN (true north aligned to bottom)
        ctx.strokeStyle = "rgba(0,0,0,0.85)";
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(cx, cy - r*0.55);
        ctx.lineTo(cx, cy + r*0.35);
        ctx.stroke();

        // arrow head
        ctx.beginPath();
        ctx.moveTo(cx - r*0.22, cy + r*0.18);
        ctx.lineTo(cx, cy + r*0.45);
        ctx.lineTo(cx + r*0.22, cy + r*0.18);
        ctx.closePath();
        ctx.fill();

        // "N"
        ctx.font = `${isMobile() ? 18 : 16}px system-ui, -apple-system, Segoe UI, Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
ctx.restore();
      }

    }

    function begin(clientX, clientY){
      if (!imgLoaded) return;
      const p = clientToCanvas(clientX, clientY);

      // North tool: draw an arrow (base -> tip). On release we auto-rotate the GRID so the arrow points down.
      if (northMode) {
        if (activeLayer !== "grid") { northMode = false; return; }
        isDragging = true;
        activeHandle = null;
        activeLayer = "grid";
        northDrawing = true;
        northP1 = { x: p.x, y: p.y };
        northP2 = { x: p.x, y: p.y };
        lastPointer = p;
        draw();
        return;
      }

// Decide which layer the user is trying to edit
      // Priority: handles > inside grid rect > image
      const gridHandle = showGrid ? hitTestHandle("grid", p.x, p.y) : null;
      const imgHandle = imageLocked ? null : hitTestHandle("image", p.x, p.y);

      if (gridHandle){
        selectedLayer = "grid";
        activeLayer = "grid";
        activeHandle = gridHandle;
      } else if (imgHandle){
        selectedLayer = "image";
        activeLayer = "image";
        activeHandle = imgHandle;
      } else if (showGrid && pointInLayerRect("grid", p.x, p.y)){
        selectedLayer = "grid";
        activeLayer = "grid";
        activeHandle = null;
      } else {
        if (imageLocked) {
          selectedLayer = "grid";
          activeLayer = "grid";
          activeHandle = null;
        } else {
          selectedLayer = "image";
          activeLayer = "image";
          activeHandle = null;
        }
      }

      isDragging = true;
      lastPointer = p;
      draw();
    }

    function move(clientX, clientY){
      if (!isDragging || !imgLoaded) return;
      const p = clientToCanvas(clientX, clientY);
      
      if (northDrawing) {
        northP2 = { x: p.x, y: p.y };
        lastPointer = p;
        draw();
        return;
      }

const dxc = p.x - lastPointer.x;
      const dyc = p.y - lastPointer.y;

      // Pan layer if not dragging a handle
      if (!activeHandle){
        if (imageLocked) activeLayer = "grid";
        if (activeLayer === "grid"){
          offset = { x: offset.x + dxc, y: offset.y + dyc };
        } else {
          imgOffset = { x: imgOffset.x + dxc, y: imgOffset.y + dyc };
        }
        lastPointer = p;
        syncControls();
        draw();
        return;
      }

      const isCorner = ["tl","tr","bl","br"].includes(activeHandle);

      // rotation delta around the layer pivot
      const pivot = getPivot(activeLayer);
      const a1 = Math.atan2(lastPointer.y - pivot.y, lastPointer.x - pivot.x);
      const a2 = Math.atan2(p.y - pivot.y, p.x - pivot.x);
      const deltaDeg = (a2 - a1) * 180 / Math.PI;

      // Shift = rotate only
      if (isShift){
        if (activeLayer === "grid") rotation = normDeg(rotation + deltaDeg);
        else imgRotation = normDeg(imgRotation + deltaDeg);
        lastPointer = p;
        syncControls();
        draw();
        return;
      }

      if (activeLayer === "grid"){
        // Grid: FREE-FORM resize.
        // Edges: resize only that dimension, anchoring the opposite edge.
        // Corners: rotate + resize width/height independently, anchoring opposite corner.
        const minW = 40, minH = 40;

        const prevSize = { w: gridSize.w, h: gridSize.h };
        const prevRot  = rotation;

        const nextRot = isCorner ? normDeg(rotation + deltaDeg) : rotation;
        if (isCorner && deltaDeg !== 0) rotation = nextRot;

        const anchorName = OPP_HANDLE[activeHandle];
        const pivotPrev = getPivot("grid");
        const anchorLocalPrev = localForHandleFromSize(anchorName, prevSize);
        const anchorCanvas = localToCanvasGridAt(anchorLocalPrev.x, anchorLocalPrev.y, prevRot, pivotPrev, zoom);

        // Pointer in anchor-centered local coords (using nextRot)
        const dx = p.x - anchorCanvas.x;
        const dy = p.y - anchorCanvas.y;
        const rad = degToRad(nextRot);
        const cos = Math.cos(rad), sin = Math.sin(rad);
        // inverse rotate then unscale
        const xr = ( dx * cos + dy * sin) / zoom;
        const yr = (-dx * sin + dy * cos) / zoom;

        let newW = prevSize.w;
        let newH = prevSize.h;

        if (isCorner){
          // Opposite corner anchored: pointer gives the dragged corner position in local space.
          newW = Math.round(Math.max(minW, Math.abs(xr) * 2));
          newH = Math.round(Math.max(minH, Math.abs(yr) * 2));
        } else if (activeHandle === "t"){
          // bottom anchored; dragging up => yr negative
          newH = Math.round(Math.max(minH, -yr));
          newW = prevSize.w;
        } else if (activeHandle === "b"){
          newH = Math.round(Math.max(minH, yr));
          newW = prevSize.w;
        } else if (activeHandle === "l"){
          newW = Math.round(Math.max(minW, -xr));
          newH = prevSize.h;
        } else if (activeHandle === "r"){
          newW = Math.round(Math.max(minW, xr));
          newH = prevSize.h;
        }

        // Update size
        gridSize = { w: newW, h: newH };

        // Recompute pivot so the anchor stays fixed in canvas space
        const Wc = (meta.canvasWidth || meta.naturalWidth || canvas.width);
        const Hc = (meta.canvasHeight || meta.naturalHeight || canvas.height);
        const canvasCenter = { x: Wc/2, y: Hc/2 };

        const anchorLocalNew = localForHandleFromSize(anchorName, gridSize);
        const ax = anchorLocalNew.x * zoom;
        const ay = anchorLocalNew.y * zoom;
        const aRotX = ax * cos - ay * sin;
        const aRotY = ax * sin + ay * cos;

        const pivotDesired = { x: anchorCanvas.x - aRotX, y: anchorCanvas.y - aRotY };
        offset = { x: pivotDesired.x - canvasCenter.x, y: pivotDesired.y - canvasCenter.y };
      } else {
        // Image: corners rotate + scale; edges scale only (uniform)
        const nextRot = isCorner ? normDeg(imgRotation + deltaDeg) : imgRotation;
        if (isCorner && deltaDeg !== 0) imgRotation = nextRot;

        const local = canvasToLocalAtRot("image", p.x, p.y, nextRot);
        const hw0 = meta.naturalWidth/2;
        const hh0 = meta.naturalHeight/2;

        let scale = imgZoom;
        if (isCorner){
          scale = Math.max(Math.abs(local.x)/hw0, Math.abs(local.y)/hh0);
        } else if (activeHandle === "l" || activeHandle === "r"){
          scale = Math.abs(local.x)/hw0;
        } else if (activeHandle === "t" || activeHandle === "b"){
          scale = Math.abs(local.y)/hh0;
        }
        imgZoom = clamp(scale, 0.05, 20);
      }

      lastPointer = p;
      syncControls();
      draw();
    }

    function end(){
      if (northDrawing) {
        northDrawing = false;
        // Auto-rotate grid so North points down
        alignGridNorthToBottom(northP1, northP2);
        northMode = false;
        draw();
        return;
      }


      isDragging = false;
      activeHandle = null;
    }

    canvas.addEventListener("mousedown", (e) => { e.preventDefault(); begin(e.clientX, e.clientY); });
    window.addEventListener("mousemove", (e) => move(e.clientX, e.clientY));
    window.addEventListener("mouseup", () => end());

    // touch
    
    // touch (mobile): 1-finger = existing drag/resize/rotate via handles
    // 2-finger = gesture transform (pan + pinch zoom + rotate) for the whole grid
    let gesture = {
      active: false,
      startDist: 0,
      startAngle: 0,
      startZoom: 1,
      startRotation: 0,
      startOffset: { x: 0, y: 0 },
      startCenter: { x: 0, y: 0 },
      layer: "grid",
    };

    function touchInfo2(e){
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const cx = (t1.clientX + t2.clientX) / 2;
      const cy = (t1.clientY + t2.clientY) / 2;
      const dx = t2.clientX - t1.clientX;
      const dy = t2.clientY - t1.clientY;
      const dist = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx); // radians
      return { cx, cy, dist, angle };
    }

    canvas.addEventListener("touchstart", (e) => {
      if (!imgLoaded) return;
      if (!e.touches || e.touches.length < 1) return;

      // Prevent page scroll while interacting
      e.preventDefault();

      if (e.touches.length === 1) {
        const t = e.touches[0];
        gesture.active = false;
        begin(t.clientX, t.clientY);
        return;
      }

      if (e.touches.length >= 2) {
        // two-finger gesture mode
        end(); // stop any handle drag
        gesture.active = true;

        const info = touchInfo2(e);
        const centerCanvas = clientToCanvas(info.cx, info.cy);

        gesture.startCenter = centerCanvas;
        gesture.startDist = info.dist;
        gesture.startAngle = info.angle;
        // Choose layer based on gesture center (Option A)
        gesture.layer = imageLocked ? "grid" : ((showGrid && pointInLayerRect("grid", centerCanvas.x, centerCanvas.y)) ? "grid" : "image");
        selectedLayer = gesture.layer;
        activeLayer = gesture.layer;

        if (gesture.layer === "grid"){
          gesture.startZoom = zoom;
          gesture.startRotation = rotation;
          gesture.startOffset = { x: offset.x, y: offset.y };
        } else {
          gesture.startZoom = imgZoom;
          gesture.startRotation = imgRotation;
          gesture.startOffset = { x: imgOffset.x, y: imgOffset.y };
        }
      }
    }, { passive:false });

    canvas.addEventListener("touchmove", (e) => {
      if (!imgLoaded) return;
      if (!e.touches || e.touches.length < 1) return;

      e.preventDefault();

      if (gesture.active && e.touches.length >= 2) {
        const info = touchInfo2(e);
        const centerCanvas = clientToCanvas(info.cx, info.cy);

        // Pan: move selected layer by center movement (in canvas/image px)
        const panDx = centerCanvas.x - gesture.startCenter.x;
        const panDy = centerCanvas.y - gesture.startCenter.y;

        // Pinch zoom
        const ratio = (gesture.startDist > 0) ? (info.dist / gesture.startDist) : 1;

        // Rotate
        const deltaRad = info.angle - gesture.startAngle;
        const deltaDeg = deltaRad * 180 / Math.PI;

        if (gesture.layer === "grid"){
          offset = { x: gesture.startOffset.x + panDx, y: gesture.startOffset.y + panDy };
          zoom = clamp(gesture.startZoom * ratio, 0.1, 5);
          rotation = normDeg(gesture.startRotation + deltaDeg);
        } else {
          imgOffset = { x: gesture.startOffset.x + panDx, y: gesture.startOffset.y + panDy };
          imgZoom = clamp(gesture.startZoom * ratio, 0.05, 20);
          imgRotation = normDeg(gesture.startRotation + deltaDeg);
        }

        syncControls();
        // auto-expand disabled (finite workspace)
        draw();
        return;
      }

      // single finger drag path
      const t = e.touches[0];
      move(t.clientX, t.clientY);
    }, { passive:false });

    canvas.addEventListener("touchend", (e) => {
      // If gesture was active and one finger remains, smoothly transition into 1-finger dragging
      if (gesture.active && e.touches && e.touches.length === 1) {
        gesture.active = false;
        const t = e.touches[0];
        // start a new single-finger drag from current position
        begin(t.clientX, t.clientY);
        return;
      }

      // If fewer than 2 touches remain, end gesture/drag
      if (!e.touches || e.touches.length < 2) {
        gesture.active = false;
        end();
      }
    });

    canvas.addEventListener("touchcancel", () => {
      gesture.active = false;
      end();
    });


    // wheel zoom
    canvas.addEventListener("wheel", (e) => {
      if (!imgLoaded) return;
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.05 : 0.05;
      zoom = clamp(zoom + delta, 0.1, 5);
      syncControls();
      // auto-expand disabled (finite workspace)
      draw();
    }, { passive:false });

    // cursor hint on desktop
    canvas.addEventListener("mousemove", (e) => {
      if (!imgLoaded || isDragging) return;
      const p = clientToCanvas(e.clientX, e.clientY);
      const h = hitTestHandle(p.x, p.y);
      canvas.style.cursor = h ? "pointer" : (isShift ? "crosshair" : "grab");
    });

    // ---------- Export (hide dots) ----------
    
    // ---------- Export (hide dots) ----------
    function isIOS() {
      const ua = navigator.userAgent || "";
      const iOS = /iPad|iPhone|iPod/.test(ua);
      const isMS = /Macintosh/.test(ua) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1; // iPadOS masquerading as Mac
      return iOS || isMS;
    }

    
    function sanitizeFilenameBase(name){
      // Remove extension if user typed it, trim, and replace illegal filename chars.
      let base = (name || "").trim();
      base = base.replace(/\.png$/i, "");
      // Windows-illegal and generally problematic chars: \ / : * ? " < > | plus control chars
      base = base.replace(/[\\\/:*?"<>|\x00-\x1F]/g, "_");
      // Collapse whitespace
      base = base.replace(/\s+/g, " ").trim();
      // Avoid empty
      if (!base) base = "gridology";
      return base;
    }

    function downloadImage(){
      if (!imgLoaded) return;

      const promptText = (lang === "zh-TW") ? "Ë´ãËº∏ÂÖ•Ê™îÂêçÔºà‰∏çÂê´ÂâØÊ™îÂêç .pngÔºâ" : "Enter filename (without extension .png)";
      const input = window.prompt(promptText, lastExportName);
      if (input === null) return;

      lastExportName = sanitizeFilenameBase(input);
      localStorage.setItem("gridology_filename", lastExportName);
      const filename = `${lastExportName}.png`;

      const iOS = isIOS();
      let iosTab = null;
      if (iOS) iosTab = window.open("about:blank", "_blank");

      // Backup workspace/state so we can expand for export without affecting the editor after download
      const _prev = {
        canvasW: meta.canvasWidth || 0,
        canvasH: meta.canvasHeight || 0,
        offX: offset.x, offY: offset.y,
        imgOffX: imgOffset.x, imgOffY: imgOffset.y
      };

      exportMode = true;
      // Expand workspace as needed so export won't crop rotated/scaled layers
      for (let i=0; i<8; i++) { if (!ensureWorkspaceFitsAllLayers()) break; }
      draw();

      const finish = () => {
        exportMode = false;

        // Restore workspace/state after export (if it was expanded)
        if (_prev.canvasW) meta.canvasWidth = _prev.canvasW;
        if (_prev.canvasH) meta.canvasHeight = _prev.canvasH;
        offset.x = _prev.offX; offset.y = _prev.offY;
        imgOffset.x = _prev.imgOffX; imgOffset.y = _prev.imgOffY;

        layoutCanvas();
        draw();
      };

      const deliverToIOS = (urlOrData) => {
        finish();
        if (iosTab) { try { iosTab.location.href = urlOrData; } catch(e) {} return; }
        window.open(urlOrData, "_blank");
        setTimeout(() => {
          alert((lang === "zh-TW")
            ? "Ëã•Êú™Ëá™ÂãïÂÑ≤Â≠òÔºöÂú®Êñ∞È†ÅÈù¢Èï∑ÊåâÂúñÁâá ‚Üí ÈÅ∏„ÄåÂä†ÂÖ•ÁÖßÁâá„ÄçÊàñ„ÄåÂÑ≤Â≠òÂúñÁâá„Äç„ÄÇ"
            : "If it didn‚Äôt save automatically: in the new tab, long-press the image and choose Save/Add to Photos.");
        }, 50);
      };

      const doExport = () => {
        if (canvas.toBlob) {
          canvas.toBlob(async (blob) => {
            if (!blob) {
              const dataUrl = canvas.toDataURL("image/png");
              if (iOS) deliverToIOS(dataUrl);
              else {
                finish();
                const a = document.createElement("a");
                a.download = filename;
                a.href = dataUrl;
                a.click();
              }
              return;
            }

            const file = new File([blob], filename, { type: "image/png" });
            if (navigator.canShare && navigator.canShare({ files: [file] })) {
              try {
                finish();
                await navigator.share({ files: [file], title: filename });
                return;
              } catch (e) {}
            }

            const url = URL.createObjectURL(blob);
            if (iOS) {
              deliverToIOS(url);
              setTimeout(() => URL.revokeObjectURL(url), 60000);
              return;
            }

            finish();
            const a = document.createElement("a");
            a.download = filename;
            a.href = url;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 10000);
          }, "image/png");
          return;
        }

        const dataUrl = canvas.toDataURL("image/png");
        if (iOS) deliverToIOS(dataUrl);
        else {
          finish();
          const a = document.createElement("a");
          a.download = filename;
          a.href = dataUrl;
          a.click();
        }
      };

      requestAnimationFrame(() => requestAnimationFrame(doExport));
    }


    // initial language + labels
    applyLang();
    syncControls();
    updateControlsButton();
  
</script>

<div id="helpModal" style="
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.45);
  z-index:9999;
">
  <div style="
    background:#fff;
    max-width:720px;
    margin:40px auto;
    padding:20px;
    border-radius:12px;
    font-size:15px;
    line-height:1.7;
    color:#222;
  ">
    <h3 style="margin-top:0;">‰ΩøÁî®Ë™™Êòé</h3>

    <p><strong>1. ‰∏äÂÇ≥ÂúñÁâá</strong><br>
    ÈªûÊìä„Äå‰∏äÂÇ≥ÂúñÁâá„ÄçÔºåÂæûÊâãÊ©üÈÅ∏ÊìáÂúñÁâá„ÄÇ</p>

    <p><strong>2. Ë™øÊï¥ÂúñÁâá</strong><br>
    ‰∏ÄÊ†πÊâãÊåáÊãñÂãïÂèØÁßªÂãïÂúñÁâáÔºå<br>
    ÂÖ©Ê†πÊâãÊåáÂèØÊîæÂ§ß„ÄÅÁ∏ÆÂ∞èÊàñÊóãËΩâÂúñÁâá„ÄÇ</p>

    <p><strong>3. Ë™øÊï¥‰πùÂÆÆÊ†º</strong><br>
    Èªû‰∏Ä‰∏ã‰πùÂÆÆÊ†ºÂç≥ÂèØÈÅ∏Êìá„ÄÇ<br>
    ÂÖ©Ê†πÊâãÊåáÂèØÁßªÂãïÊàñÊóãËΩâ‰πùÂÆÆÊ†ºÔºå<br>
    ÊãñÂãïÈÇäÁ∑£ÂèØË™øÊï¥Â§ßÂ∞è„ÄÇ</p>

    <p><strong>4. Ë®≠ÂÆöÂåóÊñπ‰ΩçÁΩÆÔºàÂåóÊñπ‰ΩçÁΩÆÔºâ</strong><br>
    ÈªûÊìä„ÄåÂåóÊñπ‰ΩçÁΩÆ„ÄçÔºå<br>
    Âú®Áï´Èù¢‰∏äÁî®ÊâãÊåáÁï´‰∏ÄÊ¢ùÁÆ≠È†≠Ôºå<br>
    ÊîæÈñãÊâãÊåáÂæåÔºå‰πùÂÆÆÊ†ºÊúÉ‰æùÁÆ≠È†≠ÊñπÂêëËá™ÂãïÂ∞çÈΩä„ÄÇ</p>

    <p><strong>5. ‰∏ãËºâÂúñÁâá</strong><br>
    ÈªûÊìä„Äå‰∏ãËºâ„ÄçÔºåËº∏ÂÖ•Ê™îÂêçÂç≥ÂèØÂÑ≤Â≠òÂúñÁâá„ÄÇ</p>

    <div style="text-align:right;">
      <button onclick="document.getElementById('helpModal').style.display='none'">
        ÈóúÈñâ
      </button>
    </div>
  </div>
</div>

</body>
</html>
