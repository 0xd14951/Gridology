<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Gridology</title>
  <style>
    :root{
      --bg1:#667eea;
      --bg2:#764ba2;
      --card:#ffffff;
      --muted:#6b7280;
      --text:#111827;
      --border:#e5e7eb;
      --panel:#f9fafb;
      --shadow: 0 18px 50px rgba(0,0,0,.22);
      --radius: 16px;
      --radius2: 14px;
      --btn:#111827;
      --btn2:#3b82f6;
      --btn3:#10b981;
      --btn4:#f59e0b;
      --touch: 44px;
    }
    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
      color: var(--text);
      padding: env(safe-area-inset-top) 14px calc(env(safe-area-inset-bottom) + 14px);
    }
    .appWrap{ max-width:1100px; margin:0 auto; }
    .card{ background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden; }
    .topbar{
      padding: 16px 16px 10px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .title{ font-size:20px; font-weight:900; margin:0; letter-spacing:-.2px; }
    .subtitle{ margin:6px 0 0; font-size:13px; color:var(--muted); line-height:1.35; max-width: 760px; }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn{
      appearance:none;
      border:none;
      border-radius:12px;
      padding:10px 12px;
      min-height:40px;
      font-weight:900;
      font-size:13px;
      color:#fff;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,.14);
      touch-action: manipulation;
      transform: translateZ(0);
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{ background:var(--btn); }
    .btn.ghost{ background:#fff; color:var(--text); border:2px solid var(--border); box-shadow:none; }
    .btn.amber{ background: var(--btn4); }

    .content{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 14px;
      padding: 14px;
    }
    .stage{
      background:#f3f4f6;
      border-radius:var(--radius2);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:380px;
      position:relative;
    }
    .stageHint{
      position:absolute;
      left: 10px;
      top: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.9);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      display:none;
      gap:8px;
      align-items:center;
      z-index: 2;
      user-select:none;
    }
    .pillDot{ width:8px; height:8px; border-radius:99px; background:#ef4444; display:inline-block; }

    .panel{
      background: var(--panel);
      border-radius: var(--radius2);
      border: 1px solid var(--border);
      padding: 12px;
      position: sticky;
      top: 12px;
      height: fit-content;
    }
    .panel.hiddenDesktop{ display:none; }

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .panelTitle{ margin:0; font-size:14px; font-weight:900; color:#374151; }
    .toggleRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px;
      background:#fff;
      border:1px solid var(--border);
      border-radius:12px;
      margin-bottom:10px;
      cursor:pointer;
      user-select:none;
      min-height: var(--touch);
    }
    .toggleRow .lbl{ font-size:13px; font-weight:900; color:#374151; }
    .switch{ width:44px; height:26px; border-radius:999px; background:#e5e7eb; position:relative; flex:none; }
    .switch.on{ background:#111827; }
    .switchDot{ width:22px; height:22px; background:#fff; border-radius:999px; position:absolute; top:2px; left:2px; transition:transform .15s ease; box-shadow:0 4px 10px rgba(0,0,0,.15); }
    .switch.on .switchDot{ transform: translateX(18px); }

    .sliderBlock{
      background:#fff;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      margin-bottom:10px;
    }
    .sliderLabel{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:baseline;
      margin-bottom:8px;
      color:#374151;
      font-size:13px;
      font-weight:900;
    }
    .sliderValue{ color:var(--muted); font-weight:800; font-size:12px; white-space:nowrap; }
    input[type="range"]{ width:100%; height:28px; cursor:pointer; min-height: var(--touch); }

    .help{
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .drop{
      margin: 14px;
      border: 2px dashed #94a3b8;
      border-radius: var(--radius2);
      padding: 42px 16px;
      text-align:center;
      background: #f8fafc;
      cursor:pointer;
      user-select:none;
    }
    .drop .big{ font-size:16px; font-weight:900; margin: 10px 0 6px; color:#334155; }
    .drop .small{ font-size:13px; color: var(--muted); }
    .kbdTag{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 6px;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      color: #111827;
      white-space: nowrap;
    }

    @media (max-width: 860px){
      body{ padding: env(safe-area-inset-top) 10px calc(env(safe-area-inset-bottom) + 10px); }
      .topbar{ padding: 14px 14px 10px; }
      .title{ font-size:18px; }
      .subtitle{ font-size:12.5px; }
      .content{ grid-template-columns: 1fr; padding: 12px; }
      .stage{ min-height: 54vh; }
      .stageHint{ display:flex; }
      .panel{
        position: fixed;
        left: 10px;
        right: 10px;
        bottom: calc(env(safe-area-inset-bottom) + 10px);
        top: auto;
        z-index: 30;
        max-height: 52vh;
        overflow: auto;
        box-shadow: var(--shadow);
        display:none;
      }
      .panel.open{ display:block; }
      .panelHeader .btn{ min-height: 40px; }
    }
  </style>
</head>
<body>
  <div class="appWrap">
    <div class="card">
      <div class="topbar">
        <div>
          <h1 class="title" id="title"></h1>
          <p class="subtitle" id="subtitle"></p>
        </div>
        <div class="actions" id="actions">
          <button class="btn ghost" id="langBtn" title="Language">‰∏≠Êñá</button>
        </div>
      </div>

      <div id="drop" class="drop">
        <div style="font-size:34px">üñºÔ∏è</div>
        <div class="big" id="dropTitle"></div>
        <div class="small" id="dropSub"></div>
        <input id="file" type="file" accept="image/*" style="display:none" />
      </div>

      <div id="content" class="content" style="display:none">
        <div class="stage">
          <div class="stageHint"><span class="pillDot"></span><span id="stageHint"></span></div>
          <canvas id="canvas" style="max-width:100%; max-height:70vh; display:block; touch-action:none;"></canvas>
        </div>

        <div id="panel" class="panel">
          <div class="panelHeader">
            <div class="panelTitle" id="controlsTitle"></div>
            <button class="btn ghost" id="closePanelBtn" style="display:none"></button>
          </div>

          <div id="toggleGridRow" class="toggleRow" role="button">
            <div class="lbl" id="showGridLbl"></div>
            <div class="switch" id="gridSwitch"><div class="switchDot"></div></div>
          </div>

          <div class="sliderBlock">
            <div class="sliderLabel"><span id="rotLbl"></span><span class="sliderValue" id="rotVal"></span></div>
            <input id="rot" type="range" min="-180" max="180" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="zoomLbl"></span><span class="sliderValue" id="zoomVal"></span></div>
            <input id="zoom" type="range" min="0.1" max="5" step="0.05" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="gwLbl"></span><span class="sliderValue" id="gwVal"></span></div>
            <input id="gw" type="range" min="40" max="6000" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="ghLbl"></span><span class="sliderValue" id="ghVal"></span></div>
            <input id="gh" type="range" min="40" max="6000" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="pxLbl"></span><span class="sliderValue" id="pxVal"></span></div>
            <input id="px" type="range" min="-4000" max="4000" step="1" />
          </div>
          <div class="sliderBlock">
            <div class="sliderLabel"><span id="pyLbl"></span><span class="sliderValue" id="pyVal"></span></div>
            <input id="py" type="range" min="-4000" max="4000" step="1" />
          </div>

          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:6px">
            <button class="btn amber" id="resetBtn"></button>
            <button class="btn ghost" id="newBtn"></button>
          </div>

          <div class="help">
            <strong id="tipsTitle"></strong><br/>
            <div id="tips"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- i18n ----------
    const I18N = {
      en: {
        title: "Gridology",
        subtitle: `Drag to move. Drag the corner dots to rotate + resize. Drag edge dots to resize. Scroll to zoom. Hold <span class="kbdTag">Shift</span> to rotate only. <span class="kbdTag">Ctrl/‚åò+S</span> to download.`,
        dropTitle: "Tap to upload or drop an image",
        dropSub: "PNG/JPG/GIF ‚Ä¢ exported as PNG with overlay",
        stageHint: "Drag canvas ‚Ä¢ Controls (optional)",
        download: "Download",
        controls: "Controls",
        showControls: "Controls",
        hideControls: "Hide Controls",
        close: "Close",
        showGrid: "Show grid",
        rotation: "Rotation",
        zoom: "Zoom",
        gridWidth: "Grid width",
        gridHeight: "Grid height",
        posX: "Position X",
        posY: "Position Y",
        reset: "Reset",
        newImage: "New image",
        tipsTitle: "Mobile tips",
        tips: [
          "Pinch to zoom. Use two fingers to rotate + move the grid.",
          "Corner dots rotate + resize. Edge dots resize only.",
          "Hold Shift for rotation-only."
        ],
        langToggle: "‰∏≠Êñá",
        langLabel: "Language",
      },
      "zh-TW": {
        title: "Gridology",
        subtitle: `ÊãñÊõ≥Âç≥ÂèØÁßªÂãï„ÄÇÊãñÊõ≥ÂõõÂÄãËßíÈªûÂèØ„ÄåÊóãËΩâÔºãË™øÊï¥Â§ßÂ∞è„ÄçÔºåÊãñÊõ≥ÈÇäÈªûÂè™ÊúÉË™øÊï¥Â§ßÂ∞è„ÄÇÊªëÂãïÂç≥ÂèØÁ∏ÆÊîæ„ÄÇÊåâ‰Ωè <span class="kbdTag">Shift</span> ÂèØÂè™ÈÄ≤Ë°åÊóãËΩâ„ÄÇÊåâ <span class="kbdTag">Ctrl/‚åò+S</span> ‰∏ãËºâ„ÄÇ`,
        dropTitle: "ÈªûÊìä‰∏äÂÇ≥ÊàñÊãñÊõ≥ÂúñÁâá",
        dropSub: "PNG/JPG/GIF ‚Ä¢ ÂåØÂá∫ÁÇ∫Âê´ÁñäÂä†ÂúñÂ±§ÁöÑ PNG",
        stageHint: "ÊãñÊõ≥Áï´Èù¢ ‚Ä¢ ÊéßÂà∂È†ÖÔºàÂèØÈÅ∏Ôºâ",
        download: "‰∏ãËºâ",
        controls: "ÊéßÂà∂È†Ö",
        showControls: "ÊéßÂà∂È†Ö",
        hideControls: "Èö±ËóèÊéßÂà∂È†Ö",
        close: "ÈóúÈñâ",
        showGrid: "È°ØÁ§∫‰πùÂÆÆÊ†º",
        rotation: "ÊóãËΩâËßíÂ∫¶",
        zoom: "Á∏ÆÊîæ",
        gridWidth: "‰πùÂÆÆÊ†ºÂØ¨Â∫¶",
        gridHeight: "‰πùÂÆÆÊ†ºÈ´òÂ∫¶",
        posX: "Ê∞¥Âπ≥‰ΩçÁΩÆ",
        posY: "ÂûÇÁõ¥‰ΩçÁΩÆ",
        reset: "ÈáçË®≠",
        newImage: "‰∏äÂÇ≥Êñ∞ÂúñÁâá",
        tipsTitle: "ÊâãÊ©üÊìç‰ΩúÊèêÁ§∫",
        tips: [
          "ÈõôÊåáÂèØÁ∏ÆÊîæÔºõÈõôÊåáÊóãËΩâÂèØËΩâÂãïÁ∂≤Ê†ºÔºõÈõôÊåáÁßªÂãïÂèØÂπ≥ÁßªÁ∂≤Ê†º„ÄÇ",
          "ËßíÈªûÔºöÊóãËΩâÔºãË™øÊï¥Â§ßÂ∞èÔºõÈÇäÈªûÔºöÂè™Ë™øÊï¥Â§ßÂ∞è„ÄÇ",
          "Êåâ‰Ωè Shift ÂèØÂè™ÊóãËΩâ„ÄÇ"
        ],
        langToggle: "EN",
        langLabel: "Ë™ûË®Ä",
      },
    };

    function detectLang(){
      const saved = localStorage.getItem("grid_lang");
      if (saved && I18N[saved]) return saved;
      const nav = (navigator.language || "").toLowerCase();
      if (nav.startsWith("zh")) return "zh-TW";
      return "en";
    }

    let lang = detectLang();
    let lastExportName = localStorage.getItem("gridology_filename") || "gridology";
    function t(k){ return (I18N[lang] && I18N[lang][k]) || I18N.en[k] || k; }
    function applyLang(){
      document.documentElement.lang = lang;
      localStorage.setItem("grid_lang", lang);
      document.getElementById("title").textContent = t("title");
      document.getElementById("subtitle").innerHTML = t("subtitle");
      document.getElementById("dropTitle").textContent = t("dropTitle");
      document.getElementById("dropSub").textContent = t("dropSub");
      document.getElementById("stageHint").textContent = t("stageHint");
      document.getElementById("controlsTitle").textContent = t("controls");
      document.getElementById("showGridLbl").textContent = t("showGrid");
      document.getElementById("rotLbl").textContent = t("rotation");
      document.getElementById("zoomLbl").textContent = t("zoom");
      document.getElementById("gwLbl").textContent = t("gridWidth");
      document.getElementById("ghLbl").textContent = t("gridHeight");
      document.getElementById("pxLbl").textContent = t("posX");
      document.getElementById("pyLbl").textContent = t("posY");
      document.getElementById("resetBtn").textContent = t("reset");
      document.getElementById("newBtn").textContent = t("newImage");
      document.getElementById("tipsTitle").textContent = t("tipsTitle");
      const tips = t("tips");
      document.getElementById("tips").innerHTML = (Array.isArray(tips) ? tips : String(tips).split("\n"))
        .map(line => `<div>‚Ä¢ ${line}</div>`).join("");
      document.getElementById("langBtn").textContent = t("langToggle");
      document.getElementById("langBtn").title = t("langLabel");

      // control button label updated in updateControlsButton()
      updateControlsButton();
    }

    // ---------- State ----------
    const GRID_COLOR = "#ff0000";
    const GRID_OPACITY = 1.0;
    const LINE_WIDTH_PX = 5;

    let img = null;
    let imgLoaded = false;

    let showGrid = true;
    let rotation = 0;   // degrees
    let zoom = 1.0;
    let offset = { x: 0, y: 0 }; // image pixels
    let gridSize = { w: 600, h: 600 }; // image pixels

    let exportMode = false;

    let isShift = false;
    let isDragging = false;
    let activeHandle = null; // tl,tr,bl,br,t,r,b,l or null
    let lastPointer = { x: 0, y: 0 };

    // Canvas + sizing
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const meta = { naturalWidth: 0, naturalHeight: 0, displayWidth: 0, displayHeight: 0 };

    // Controls panel: hidden by default
    let controlsOpen = false;

    function isMobile(){ return window.matchMedia && window.matchMedia("(max-width: 860px)").matches; }

    function clamp(v, mn, mx){ return Math.max(mn, Math.min(mx, v)); }
    function degToRad(d){ return (d * Math.PI) / 180; }
    function normDeg(d){
      let x = d;
      while (x > 180) x -= 360;
      while (x < -180) x += 360;
      return x;
    }

    // ---------- UI wiring ----------
    const drop = document.getElementById("drop");
    const fileInput = document.getElementById("file");
    const content = document.getElementById("content");
    const panel = document.getElementById("panel");
    const closePanelBtn = document.getElementById("closePanelBtn");
    const actions = document.getElementById("actions");
    const langBtn = document.getElementById("langBtn");

    // Add action buttons (download + controls) once image is loaded
    const downloadBtn = document.createElement("button");
    downloadBtn.className = "btn primary";
    downloadBtn.addEventListener("click", () => downloadImage());
    actions.insertBefore(downloadBtn, langBtn);
    downloadBtn.style.display = "none";

    const controlsBtn = document.createElement("button");
    controlsBtn.className = "btn ghost";
    controlsBtn.addEventListener("click", () => toggleControls());
    actions.insertBefore(controlsBtn, langBtn);
    controlsBtn.style.display = "none";

    function updateControlsButton(){
      const hasImage = !!imgLoaded;
      downloadBtn.style.display = hasImage ? "inline-block" : "none";
      controlsBtn.style.display = hasImage ? "inline-block" : "none";
      controlsBtn.textContent = controlsOpen ? t("hideControls") : t("showControls");
      downloadBtn.textContent = t("download");
      closePanelBtn.textContent = t("close");
      // show close button only on mobile when panel open
      closePanelBtn.style.display = (isMobile() && controlsOpen) ? "inline-block" : "none";
    }

    function setControlsOpen(open){
      controlsOpen = open;
      if (isMobile()){
        panel.classList.toggle("open", controlsOpen);
      } else {
        // desktop: hide/show the right column panel
        panel.style.display = controlsOpen ? "block" : "none";
      }
      updateControlsButton();
    }

    function toggleControls(){ setControlsOpen(!controlsOpen); }

    closePanelBtn.addEventListener("click", () => setControlsOpen(false));

    // Hidden by default
    setControlsOpen(false);

    // Drag & drop + click upload
    drop.addEventListener("click", () => fileInput.click());
    drop.addEventListener("dragover", (e) => e.preventDefault());
    drop.addEventListener("drop", (e) => {
      e.preventDefault();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) loadImageFile(f);
    });
    fileInput.addEventListener("change", (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) loadImageFile(f);
      fileInput.value = "";
    });

    langBtn.addEventListener("click", () => {
      lang = (lang === "en") ? "zh-TW" : "en";
      applyLang();
    });

    // controls elements
    const gridSwitch = document.getElementById("gridSwitch");
    document.getElementById("toggleGridRow").addEventListener("click", () => {
      showGrid = !showGrid;
      gridSwitch.classList.toggle("on", showGrid);
      draw();
    });

    const rotEl = document.getElementById("rot");
    const zoomEl = document.getElementById("zoom");
    const gwEl = document.getElementById("gw");
    const ghEl = document.getElementById("gh");
    const pxEl = document.getElementById("px");
    const pyEl = document.getElementById("py");
    const rotVal = document.getElementById("rotVal");
    const zoomVal = document.getElementById("zoomVal");
    const gwVal = document.getElementById("gwVal");
    const ghVal = document.getElementById("ghVal");
    const pxVal = document.getElementById("pxVal");
    const pyVal = document.getElementById("pyVal");

    function syncControls(){
      rotEl.value = rotation;
      zoomEl.value = zoom;
      gwEl.value = gridSize.w;
      ghEl.value = gridSize.h;
      pxEl.value = offset.x;
      pyEl.value = offset.y;

      rotVal.textContent = `${rotation}¬∞`;
      zoomVal.textContent = `${zoom.toFixed(2)}x`;
      gwVal.textContent = `${gridSize.w}px`;
      ghVal.textContent = `${gridSize.h}px`;
      pxVal.textContent = `${Math.round(offset.x)}px`;
      pyVal.textContent = `${Math.round(offset.y)}px`;

      gridSwitch.classList.toggle("on", showGrid);
      updateControlsButton();
    }

    function onSlider(el, fn){
      el.addEventListener("input", () => { fn(parseFloat(el.value)); syncControls(); draw(); });
    }
    onSlider(rotEl, (v) => rotation = normDeg(v));
    onSlider(zoomEl, (v) => zoom = clamp(v, 0.1, 5));
    onSlider(gwEl, (v) => gridSize.w = Math.round(v));
    onSlider(ghEl, (v) => gridSize.h = Math.round(v));
    onSlider(pxEl, (v) => offset.x = v);
    onSlider(pyEl, (v) => offset.y = v);

    document.getElementById("resetBtn").addEventListener("click", () => {
      rotation = 0; zoom = 1.0; offset = { x: 0, y: 0 };
      syncControls(); draw();
    });

    document.getElementById("newBtn").addEventListener("click", () => {
      img = null; imgLoaded = false;
      drop.style.display = "block";
      content.style.display = "none";
      setControlsOpen(false);
          updateControlsButton();
    });

    // keyboard
    window.addEventListener("keydown", (e) => {
      if (e.key === "Shift") isShift = true;
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        downloadImage();
      }
      if (e.key.toLowerCase() === "g") {
        showGrid = !showGrid;
        syncControls(); draw();
      }
      if (e.key.toLowerCase() === "r") {
        rotation = 0; zoom = 1.0; offset = { x: 0, y: 0 };
        syncControls(); draw();
      }
      if (e.key === "Escape") {
        isDragging = false;
        activeHandle = null;
      }
    });
    window.addEventListener("keyup", (e) => { if (e.key === "Shift") isShift = false; });

    // ---------- Image loading ----------
    function loadImageFile(file){
      if (!file || !file.type || !file.type.startsWith("image/")) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const src = ev.target.result;
        const im = new Image();
        im.onload = () => {
          img = im;
          imgLoaded = true;
          meta.naturalWidth = im.naturalWidth || im.width;
          meta.naturalHeight = im.naturalHeight || im.height;

          // initial grid size: 90% of shorter side
          const short = Math.min(meta.naturalWidth, meta.naturalHeight);
          const side = Math.round(short * 0.9);
          gridSize = { w: side, h: side };
          rotation = 0; zoom = 1.0; offset = { x: 0, y: 0 };
          showGrid = true;

          // show canvas view
          drop.style.display = "none";
          content.style.display = "grid";
          setControlsOpen(false); // hidden by default as requested
          syncControls();
          layoutCanvas();
          draw();
        };
        im.src = src;
      };
      reader.readAsDataURL(file);
    }

    function layoutCanvas(){
      if (!imgLoaded) return;
      // keep internal canvas at natural size for export quality
      canvas.width = meta.naturalWidth;
      canvas.height = meta.naturalHeight;

      // display size responsive
      const vw = Math.min(window.innerWidth, 1100);
      const vh = window.innerHeight;
      const maxW = vw - 60;
      const maxH = Math.min(680, vh * 0.62);

      let dw = meta.naturalWidth, dh = meta.naturalHeight;
      if (dw > maxW) { dh = (dh * maxW) / dw; dw = maxW; }
      if (dh > maxH) { dw = (dw * maxH) / dh; dh = maxH; }

      meta.displayWidth = dw;
      meta.displayHeight = dh;

      canvas.style.width = dw + "px";
      canvas.style.height = dh + "px";
    }

    window.addEventListener("resize", () => {
      layoutCanvas();
      updateControlsButton();
    });

    // ---------- Geometry helpers ----------
    function getPivot(){
      return { x: meta.naturalWidth / 2 + offset.x, y: meta.naturalHeight / 2 + offset.y };
    }
    function localToCanvas(lx, ly){
      const p = getPivot();
      const rad = degToRad(rotation);
      const cos = Math.cos(rad), sin = Math.sin(rad);
      const x1 = lx * zoom, y1 = ly * zoom;
      const xr = x1 * cos - y1 * sin;
      const yr = x1 * sin + y1 * cos;
      return { x: p.x + xr, y: p.y + yr };
    }
    function canvasToLocalAtRot(cx, cy, rotDeg){
      const p = getPivot();
      const dx = cx - p.x;
      const dy = cy - p.y;
      const rad = degToRad(rotDeg);
      const cos = Math.cos(-rad), sin = Math.sin(-rad);
      const xr = dx * cos - dy * sin;
      const yr = dx * sin + dy * cos;
      return { x: xr / zoom, y: yr / zoom };
    }
    function getHandles(){
      const hw = gridSize.w / 2;
      const hh = gridSize.h / 2;
      const hs = [
        { name:"tl", lx:-hw, ly:-hh },
        { name:"tr", lx: hw, ly:-hh },
        { name:"bl", lx:-hw, ly: hh },
        { name:"br", lx: hw, ly: hh },
        { name:"t",  lx:  0, ly:-hh },
        { name:"r",  lx: hw, ly:  0 },
        { name:"b",  lx:  0, ly: hh },
        { name:"l",  lx:-hw, ly:  0 },
      ];
      return hs.map(h => {
        const p = localToCanvas(h.lx, h.ly);
        return { ...h, x:p.x, y:p.y };
      });
    }
    function hitTestHandle(cx, cy){
      const hs = getHandles();
      const r = 22; // generous for touch
      for (const h of hs){
        const dx = cx - h.x, dy = cy - h.y;
        if (Math.hypot(dx, dy) <= r) return h.name;
      }
      return null;
    }

    function clientToCanvas(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      return { x: (clientX - rect.left) * sx, y: (clientY - rect.top) * sy };
    }

    // ---------- Drawing ----------
    function draw(){
      if (!imgLoaded) return;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      if (!showGrid) return;

      const w = canvas.width, h = canvas.height;
      const pivot = getPivot();

      ctx.save();
      ctx.translate(pivot.x, pivot.y);
      ctx.rotate(degToRad(rotation));
      ctx.scale(zoom, zoom);

      const gw = gridSize.w, gh = gridSize.h;
      const x0 = -gw/2, y0 = -gh/2;

      ctx.strokeStyle = GRID_COLOR;
      ctx.globalAlpha = GRID_OPACITY;
      ctx.lineWidth = LINE_WIDTH_PX;

      const cellW = gw/3, cellH = gh/3;

      ctx.beginPath(); ctx.rect(x0, y0, gw, gh); ctx.stroke();

      for (let i=1;i<=2;i++){
        ctx.beginPath();
        ctx.moveTo(x0 + cellW*i, y0);
        ctx.lineTo(x0 + cellW*i, y0 + gh);
        ctx.stroke();
      }
      for (let i=1;i<=2;i++){
        ctx.beginPath();
        ctx.moveTo(x0, y0 + cellH*i);
        ctx.lineTo(x0 + gw, y0 + cellH*i);
        ctx.stroke();
      }

      if (!exportMode){
        const dotR = 10;
        ctx.globalAlpha = 1;
        ctx.fillStyle = GRID_COLOR;
        const pts = [
          { x:x0, y:y0 }, { x:x0+gw, y:y0 }, { x:x0, y:y0+gh }, { x:x0+gw, y:y0+gh },
          { x:x0+gw/2, y:y0 }, { x:x0+gw, y:y0+gh/2 }, { x:x0+gw/2, y:y0+gh }, { x:x0, y:y0+gh/2 },
        ];
        for (const p of pts){
          ctx.beginPath(); ctx.arc(p.x, p.y, dotR, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 2.5; ctx.stroke();
          ctx.strokeStyle = GRID_COLOR; ctx.lineWidth = LINE_WIDTH_PX;
        }
      }

      ctx.restore();
    }

    // ---------- Interactions ----------
    function begin(clientX, clientY){
      if (!imgLoaded) return;
      const p = clientToCanvas(clientX, clientY);
      activeHandle = hitTestHandle(p.x, p.y);
      isDragging = true;
      lastPointer = p;
    }
    function move(clientX, clientY){
      if (!isDragging || !imgLoaded) return;
      const p = clientToCanvas(clientX, clientY);
      const dx = p.x - lastPointer.x;
      const dy = p.y - lastPointer.y;

      if (!activeHandle){
        offset = { x: offset.x + dx, y: offset.y + dy };
        lastPointer = p;
        syncControls();
        draw();
        return;
      }

      const pivot = getPivot();
      const isCorner = ["tl","tr","bl","br"].includes(activeHandle);

      const a1 = Math.atan2(lastPointer.y - pivot.y, lastPointer.x - pivot.x);
      const a2 = Math.atan2(p.y - pivot.y, p.x - pivot.x);
      const deltaDeg = (a2 - a1) * 180 / Math.PI;

      if (isShift){
        rotation = normDeg(rotation + deltaDeg);
        lastPointer = p;
        syncControls();
        draw();
        return;
      }

      const nextRot = isCorner ? normDeg(rotation + deltaDeg) : rotation;
      if (isCorner && deltaDeg !== 0) rotation = nextRot;

      const local = canvasToLocalAtRot(p.x, p.y, nextRot);
      const minW = 40, minH = 40;

      let hw = gridSize.w/2, hh = gridSize.h/2;

      if (isCorner){
        hw = Math.max(minW/2, Math.abs(local.x));
        hh = Math.max(minH/2, Math.abs(local.y));
      } else if (activeHandle === "l" || activeHandle === "r"){
        hw = Math.max(minW/2, Math.abs(local.x));
        hh = gridSize.h/2;
      } else if (activeHandle === "t" || activeHandle === "b"){
        hh = Math.max(minH/2, Math.abs(local.y));
        hw = gridSize.w/2;
      }

      gridSize = { w: Math.round(hw*2), h: Math.round(hh*2) };

      lastPointer = p;
      syncControls();
      draw();
    }
    function end(){
      isDragging = false;
      activeHandle = null;
    }

    canvas.addEventListener("mousedown", (e) => { e.preventDefault(); begin(e.clientX, e.clientY); });
    window.addEventListener("mousemove", (e) => move(e.clientX, e.clientY));
    window.addEventListener("mouseup", () => end());

    // touch
    
    // touch (mobile): 1-finger = existing drag/resize/rotate via handles
    // 2-finger = gesture transform (pan + pinch zoom + rotate) for the whole grid
    let gesture = {
      active: false,
      startDist: 0,
      startAngle: 0,
      startZoom: 1,
      startRotation: 0,
      startOffset: { x: 0, y: 0 },
      startCenter: { x: 0, y: 0 },
    };

    function touchInfo2(e){
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const cx = (t1.clientX + t2.clientX) / 2;
      const cy = (t1.clientY + t2.clientY) / 2;
      const dx = t2.clientX - t1.clientX;
      const dy = t2.clientY - t1.clientY;
      const dist = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx); // radians
      return { cx, cy, dist, angle };
    }

    canvas.addEventListener("touchstart", (e) => {
      if (!imgLoaded) return;
      if (!e.touches || e.touches.length < 1) return;

      // Prevent page scroll while interacting
      e.preventDefault();

      if (e.touches.length === 1) {
        const t = e.touches[0];
        gesture.active = false;
        begin(t.clientX, t.clientY);
        return;
      }

      if (e.touches.length >= 2) {
        // two-finger gesture mode
        end(); // stop any handle drag
        gesture.active = true;

        const info = touchInfo2(e);
        const centerCanvas = clientToCanvas(info.cx, info.cy);

        gesture.startCenter = centerCanvas;
        gesture.startDist = info.dist;
        gesture.startAngle = info.angle;
        gesture.startZoom = zoom;
        gesture.startRotation = rotation;
        gesture.startOffset = { x: offset.x, y: offset.y };
      }
    }, { passive:false });

    canvas.addEventListener("touchmove", (e) => {
      if (!imgLoaded) return;
      if (!e.touches || e.touches.length < 1) return;

      e.preventDefault();

      if (gesture.active && e.touches.length >= 2) {
        const info = touchInfo2(e);
        const centerCanvas = clientToCanvas(info.cx, info.cy);

        // Pan: move grid by center movement (in canvas/image px)
        const panDx = centerCanvas.x - gesture.startCenter.x;
        const panDy = centerCanvas.y - gesture.startCenter.y;
        offset = {
          x: gesture.startOffset.x + panDx,
          y: gesture.startOffset.y + panDy,
        };

        // Pinch zoom
        const ratio = (gesture.startDist > 0) ? (info.dist / gesture.startDist) : 1;
        zoom = clamp(gesture.startZoom * ratio, 0.1, 5);

        // Rotate
        const deltaRad = info.angle - gesture.startAngle;
        const deltaDeg = deltaRad * 180 / Math.PI;
        rotation = normDeg(gesture.startRotation + deltaDeg);

        syncControls();
        draw();
        return;
      }

      // single finger drag path
      const t = e.touches[0];
      move(t.clientX, t.clientY);
    }, { passive:false });

    canvas.addEventListener("touchend", (e) => {
      // If gesture was active and one finger remains, smoothly transition into 1-finger dragging
      if (gesture.active && e.touches && e.touches.length === 1) {
        gesture.active = false;
        const t = e.touches[0];
        // start a new single-finger drag from current position
        begin(t.clientX, t.clientY);
        return;
      }

      // If fewer than 2 touches remain, end gesture/drag
      if (!e.touches || e.touches.length < 2) {
        gesture.active = false;
        end();
      }
    });

    canvas.addEventListener("touchcancel", () => {
      gesture.active = false;
      end();
    });


    // wheel zoom
    canvas.addEventListener("wheel", (e) => {
      if (!imgLoaded) return;
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.05 : 0.05;
      zoom = clamp(zoom + delta, 0.1, 5);
      syncControls();
      draw();
    }, { passive:false });

    // cursor hint on desktop
    canvas.addEventListener("mousemove", (e) => {
      if (!imgLoaded || isDragging) return;
      const p = clientToCanvas(e.clientX, e.clientY);
      const h = hitTestHandle(p.x, p.y);
      canvas.style.cursor = h ? "pointer" : (isShift ? "crosshair" : "grab");
    });

    // ---------- Export (hide dots) ----------
    
    // ---------- Export (hide dots) ----------
    function isIOS() {
      const ua = navigator.userAgent || "";
      const iOS = /iPad|iPhone|iPod/.test(ua);
      const isMS = /Macintosh/.test(ua) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1; // iPadOS masquerading as Mac
      return iOS || isMS;
    }

    
    function sanitizeFilenameBase(name){
      // Remove extension if user typed it, trim, and replace illegal filename chars.
      let base = (name || "").trim();
      base = base.replace(/\.png$/i, "");
      // Windows-illegal and generally problematic chars: \ / : * ? " < > | plus control chars
      base = base.replace(/[\\\/:*?"<>|\x00-\x1F]/g, "_");
      // Collapse whitespace
      base = base.replace(/\s+/g, " ").trim();
      // Avoid empty
      if (!base) base = "gridology";
      return base;
    }

    function downloadImage(){
      if (!imgLoaded) return;

      // Ask user for filename (without extension). Remember last value.
      const promptText = (lang === "zh-TW") ? "Ë´ãËº∏ÂÖ•Ê™îÂêçÔºà‰∏çÂê´ÂâØÊ™îÂêç .pngÔºâ" : "Enter filename (without extension .png)";
      const input = window.prompt(promptText, lastExportName);
      if (input === null) return; // cancelled

      lastExportName = sanitizeFilenameBase(input);
      localStorage.setItem("gridology_filename", lastExportName);
      const filename = `${lastExportName}.png`;

      // Hide dots during export
      exportMode = true;
      draw();

      // Use toBlob where possible (lower memory; more reliable on mobile)
      const doExport = () => {
        if (canvas.toBlob) {
          canvas.toBlob((blob) => {
            if (!blob) {
              // fallback to dataURL
              const dataUrl = canvas.toDataURL("image/png");
              exportMode = false; draw();
              if (isIOS()) {
                window.open(dataUrl, "_blank");
              } else {
                const a = document.createElement("a");
                a.download = filename;
                a.href = dataUrl;
                a.click();
              }
              return;
            }

            const url = URL.createObjectURL(blob);
            exportMode = false; draw();

            // iOS Safari often ignores download attribute; open a new tab for user to "Save Image"
            if (isIOS()) {
              window.open(url, "_blank");
              setTimeout(() => URL.revokeObjectURL(url), 60_000);
              return;
            }

            const a = document.createElement("a");
            a.download = filename;
            a.href = url;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 10_000);
          }, "image/png");
          return;
        }

        // fallback
        const dataUrl = canvas.toDataURL("image/png");
        exportMode = false; draw();
        if (isIOS()) {
          window.open(dataUrl, "_blank");
        } else {
          const a = document.createElement("a");
          a.download = filename;
          a.href = dataUrl;
          a.click();
        }
      };

      // Ensure the canvas has re-drawn without dots
      requestAnimationFrame(() => requestAnimationFrame(doExport));
    }

    // initial language + labels
    applyLang();
    syncControls();
    updateControlsButton();
  </script>
</body>
</html>
